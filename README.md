# Event forwarding

Bueno, gente, entonces tenemos nuestra modal aquí, pero ahora necesitamos una forma de alternar si se muestra o no. Recuerden que esto se controla con este valor booleano que tenemos aquí, llamado **showModal**.

Lo primero que voy a hacer es extraer este valor y ponerlo en el archivo **app.svelte**, porque quiero poder controlar si esta modale debe mostrarse desde afuera del componente. Entonces, nuevamente, vamos a usar una **prop** para hacer esto: `export let showModal`, y lo vamos a establecer como **false** al principio, porque por defecto, cuando entras a un sitio web, no deberías ser mostrado con una modale de inmediato. Deberías, por ejemplo, esperar 20 segundos antes de mostrarte una publicidad molesta, o quizás deberías hacer clic en un botón para ver esa modale. Así que voy a guardar esto allí y no deberíamos verla por defecto. ¡Perfecto!

Ahora quiero pasar esto como una **prop**. Entonces, lo primero que voy a hacer es bajar aquí donde tenemos la modale y voy a pasar el valor de **showModal**, que va a ser un booleano, **true** o **false**. Quiero que esto se guarde en una variable aquí arriba, así que voy a decir `let showModal = false` al principio, y luego paso esta variable en la prop del componente. Básicamente, lo que estamos haciendo es declarar una prop llamada **showModal** y pasar este valor, que será **true** o **false**. Esto va a sobrescribir el valor aquí. Así que si esto fuera **true** ahora y lo guardamos, debería mostrar la modale, lo cual hace. Si es **false**, entonces no se mostrará la modale, y efectivamente, no la muestra. ¡Genial, todo funciona!

Solo una cosa: cuando el nombre de la prop y el nombre de la variable que estamos usando aquí son los mismos (en este caso, **showModal**), hay una forma abreviada para esto, que es simplemente eliminar el nombre de la prop y el signo de igual, así. Esto implica que el nombre de la prop será el mismo que el valor que estás pasando, entonces **showModal**. Ok, eso es solo una forma abreviada y lo verán más adelante.

Para demostrar que esto todavía funciona, cambiemos este valor a **true**, guardemos, y vemos que sigue funcionando. ¡Todo bien! Ahora tenemos esto, necesitamos una forma de alternarlo de **false** a **true** al principio, y luego, cuando la modale está abierta, de **true** a **false** para cerrarla. Empecemos alternándolo de **false** a **true**.

Lo que quiero hacer es crear un botón dentro de esta etiqueta **main** aquí, y cuando haces clic en ese botón, va a alternar ese valor. Entonces, voy a decir `button` y vamos a poner **open modal**. Necesitamos un evento de clic en este botón, y lo vamos a establecer igual a alguna función, que se va a llamar **toggleModal**. Así que necesitamos declarar esa función aquí arriba.

Voy a decir `const toggleModal = () => {}`. Dentro de esta función, lo único que queremos hacer es tomar el valor de **showModal** y revertirlo. Así que decimos `showModal = !showModal`, ese signo de exclamación toma el valor actual y lo invierte. Entonces, si era **false**, lo convierte en **true**, y si era **true**, lo convierte en **false**. Así que cada vez que llamamos a esta función **toggleModal**, va a cambiar de **false** a **true** o de **true** a **false**. Al principio es **false**, y si hacemos clic en el botón, lo va a cambiar a **true**, y entonces debería mostrar la modale, porque eso se convierte en **true**. Así que, si lo guardamos y hacemos clic en **open modal**, esto funciona.

Pero ahora no podemos cerrarlo, así que necesitamos una forma de cerrarlo. Vamos a hacer esto desde dentro del componente **modal**, porque ahora está ocupando toda la pantalla con el fondo. Lo que quiero hacer es que cuando hagamos clic en el fondo, eso dispare el cierre de la modale. Necesitamos agregar un **onClick** aquí. Normalmente, lo que hacemos es pasar alguna función manejadora aquí y definirla arriba, pero lo que queremos llamar está en el componente **App**. No podemos simplemente decir **toggleModal** aquí porque esa función no está definida en este componente, entonces eso no va a funcionar. En su lugar, necesitamos usar algo llamado **event forwarding**.

Eso significa que básicamente pasamos este evento de clic al elemento padre. Entonces, cuando un usuario hace clic aquí, se va a pasar a este componente, y la modale va a emitir un evento de clic. La forma en que usamos el **event forwarding** es registrar el evento aquí con **on:click**, pero no lo asignamos a nada. Cuando no lo asignamos a nada, el evento se pasa al componente donde se definió, es decir, en el componente **App**. Ahora podemos escuchar ese evento de clic allí.

Así que, una vez más, estamos agregando un evento de clic al fondo. Cuando hacemos clic allí, no estamos definiendo ningún manejador en este componente, por lo que lo mirará y dirá "ok, lo voy a pasar al componente donde se usa y define", que es el componente padre. De esta forma, la modale emite ese evento de clic y cuando eso sucede, podemos hacer referencia a la función que queremos ejecutar en ese componente. Así es como solucionamos el problema de invocar una función desde el componente padre cuando un evento de clic ocurre en el componente hijo. Y podemos hacer esto en cualquier elemento dentro de este HTML. Si quisiera, por ejemplo, poner el **onClick** en este párrafo, lo podría hacer. Cuando hagamos clic allí, el evento se pasaría al componente modale.

Ahora, no quiero hacer eso. Quiero adjuntarlo al fondo, así que lo guardo. Ahora, cuando hagamos clic en el fondo, debería disparar esta función y alternar el valor de la modale. Como actualmente está mostrándose, debería cambiarlo de **true** a **false**, es decir, cerrar la modale. Probemos esto: **open modal**, y luego hacemos clic afuera. Y se cierra. ¡Genial!

Ahora, hay un problema con esto, y es que la modale se cierra incluso cuando hago clic en la parte blanca de aquí, porque eso sigue estando dentro del fondo. Estoy haciendo clic dentro de este elemento global, incluso si clickeo dentro de él. Vamos a abordar este problema en el siguiente video usando un **event modifier**.
